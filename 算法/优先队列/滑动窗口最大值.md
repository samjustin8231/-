# 问题描述
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 
针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： 
{[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

# 思路

## 方法0: 暴力法
  如果不考虑时间开销，使用蛮力法，本题并不难解决，依次遍历所有的滑动窗口，扫描每个窗口中的所有数字并找出其中的最大值，这都很容易实现，但是如果滑动窗口的大小为k，那么需要O(k)的时间找最大值，对于长度为n大的数组，总的时间复杂度为O(n * k)。



## 方法1：用优先队列(堆)
维护一个滑动窗口，用大顶堆
如果一个新元素比堆顶小，则忽略；否则进入堆，并调整堆。复杂度：NlogK (调整堆: logK)

## 思路2 dequeue
  然后我们考虑进一步优化，一个滑动窗口实际上可以看成一个队列。当窗口滑动时，处于窗口第一个位置的数字被删除，同时在窗口的末尾又增加了一个新的数字。这符合队列“先进先出”的特性。

  这里我们换用另外一种方法：使用双端队列。我们不把所有的值都加入滑动窗口，而是只把有可能成为最大值的数加入滑动窗口。这就需要一个两边都可以操作的双向队列。

### 过程举例：
我们以数组{2,3,4,2,6,2,5,1}为例，滑动窗口大小为3，先把第一个数字2加入队列，第二个数字是3，比2大，所以2不可能是最大值，所以把2删除，3存入队列。第三个数是4，比3大，同样删3存4，此时滑动窗口以遍历三个数字，最大值4在队列的头部。

  第4个数字是2，比队列中的数字4小，当4滑出去以后，2还是有可能成为最大值的，因此将2加入队列尾部，此时最大值4仍在队列的头部。

  第五个数字是6，队列的数字4和2都比它小，所以删掉4和2，将6存入队列尾部，此时最大值6在队列头部。

  第六个数字是2，此时队列中的数6比2大，所以2以后还有可能是最大值，所以加入队列尾部，此时最大值6在仍然队列头部。

  ······

  依次进行，这样每次的最大值都在队列头部。

### 思路详解：
滑动窗口：
为了满足题目要求的线性时间复杂度，我们通过利用双向链表设计一种遍历规则。

- 首先定义一个双向链表(滑动窗口记录数组的下标)，模拟滑动窗口，窗口内的元素从左到右的大小关系为大->小，数据会从窗口的右边进入
- 当一个元素来临，如果该元素大于或等于滑动窗口的最右元素，则将最右元素弹出，依次直到最右元素大于该元素或滑动窗口为空，然后将该元素压入滑动窗口
- 然后，检查最左边元素是否符合要求(是否过期)，如果过期，则将其弹出
- 将当前窗口(已形成窗口)的最左元素(最大元素)添加到结果数组中


用一个队列存放该窗口的数据，队头的始终认为最大，进来的每个数字与队头的比较，如果比队头的小则忽略；否则将队中的全部出队。 复杂度：O(N)

### 代码实现

```
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0) return nums;
        LinkedList<Integer> window = new LinkedList<Integer>();
        int[] res = new int[nums.length - k + 1];
        int index = 0;
        for(int i = 0;i < nums.length;i++){
            //弹出不符合规则的元素
            while(!window.isEmpty() && 
                  nums[i] >= nums[window.peekLast()]){
                window.pollLast();
            }
            window.addLast(i);
            //清除过期元素
            if(i - window.peekFirst() == k){
                window.pollFirst();
            }
            if(i >= k - 1){
               res[index++]  = nums[window.peekFirst()];
            }
        }
        return res;
    }
}
```

# 参考

[leetcode 239. 滑动窗口最大值](https://www.jianshu.com/p/bf49ae5aacc8)